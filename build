#!/usr/bin/env node

const execSync = require("child_process").execSync;
const fs = require("fs");
const path = require("path");
const colors = require('colors');
const separationbar = colors.green('==================================================================================================')

//const yazl = require("yazl");

const BUILD_MODE_DBG = 'debug';
const BUILD_MODE_REL = 'release';

let stdout = null;
let projDir = process.cwd();
let installDir = "_Output/tweekit";

function executeCommand(cmd, isSilent = false){
    if (!isSilent) {
        console.log('\n')
        console.log('\n')
        console.log(colors.green(separationbar))
        console.log(colors.green('Performing :'))
        console.log(colors.yellow(cmd))
        console.log(colors.green(separationbar))
        console.log('\n')
    }

    const runCMd = execSync(cmd).toString()

    if (!isSilent) {
        console.log(runCMd)
    }

    if (!isSilent) {
        console.log(colors.green(separationbar))
        console.log('\n')
    }
}

function recurseForFileNames(dir, done) {
    let results = [];
    fs.readdir(dir, (err, list) => {
        if (err)
            return done(err);
        let pending = list.length;
        if (!pending)
            return done(null, results);
        list.forEach((file) => {
            file = path.resolve(dir, file);
            fs.stat(file, (err, stat) => {
                if (stat && stat.isDirectory()) {
                    recurseForFileNames(file, (err, res) => {
                        results = results.concat(res);
                        if (!--pending)
                            done(null, results);
                    });
                }
                else {
                    results.push(file);
                    if (!--pending)
                        done(null, results);
                }
            });
        });
    });
}

async function movePkgFile(pkgFilename, version) {
    let d = path.join(packageDir, version);
    let f = path.join(d, pkgFilename);
    const exists = fs.existsSync(f);
    if (!exists) {
        fs.mkdirSync(d);
        fs.copyFileSync(pkgFilename, f, fs.constants.COPYFILE_EXCL)
        execSync("rm " + pkgFilename);
    }
    else {
        console.log("Error:file already at dst");
    }
    console.log(`Build published to:${f}`);
    return 0;
}

async function publishPkgFile(files, appName, version) {
    let r = 0;
    var pkg = new yazl.ZipFile();
    for (let i = 0; i < files.length; i++) {
        pkg.addFile(files[i], path.basename(files[i]));
    }
    pkg.end();

    let f = `${appName}-${version}.zip`;
    let ws = fs.createWriteStream(f);
    await new Promise((resolve) => {
        pkg.outputStream.pipe(ws).on("close", resolve)
    });

    return movePkgFile(f, version);
}

function clean(buildMode) {
    let installPath = path.join(installDir, buildMode);

    console.log(`Cleaning install path:${installPath}...`);
    if(fs.existsSync(installPath))
        executeCommand("rm -rf " + installPath);
    console.log("done");
}

function build(buildMode, buildType) {
    console.log(`Building ${buildMode}...`);
    if(buildMode === 'r') {
        //In release, before building bump the version
        executeCommand("npm version patch");

        if (buildType) {
            executeCommand("node node_modules/webpack/bin/webpack.js --mode production-npm");
            executeCommand("npm publish");
        } else {
            executeCommand("node node_modules/webpack/bin/webpack.js --mode production");
        }
    }
    else {
        execSync("node node_modules/webpack/bin/webpack.js --mode development");
    }
    console.log("done");
}

function usage() {
    executeCommand("clear", true)
    console.log('\n');
    console.log(separationbar);
    console.log('\n');
    console.log(`Usage:  build [${colors.green("cmds")}]`);
    console.log('\n');
    console.log("Commands:");
    console.log('\n');
    console.log(`\t ${colors.green("c")} -  Clean product of previous build`);
    console.log(`\t ${colors.green("b")}  - Build debug`);
    console.log(`\t ${colors.green("r")}  - Build release`);
    console.log('\n');
    console.log("Options:");
    console.log('\n');
    console.log(`\t ${colors.red("--npm")} - use this if you want the npm version of tweekit ( not applicable for local )`);
    console.log("Notes:");
    console.log('\n');
    console.log("\tMust be run from your projects main directory");
    console.log('\n');
    console.log(separationbar);
    console.log('\n');
}

function main() {

    console.log('process.argv ===  ', process.argv)


    const allowedBuildModes = ['b','r', 'c']
    const allowedBuildTypes = ['--npm']

    const [
        ,,
        buildMode,
        buildType
    ] = process.argv

    if (buildMode && allowedBuildModes.includes(buildMode)) {
        if (buildMode === 'c') {
            clean(buildMode);
        } else {
            // either b or r
            build(buildMode,buildType);
        }
    } else {
        usage();
    }
}

main();
