#!/usr/bin/env node

const execSync = require("child_process").execSync;
const fs = require("fs");
const path = require("path");
const colors = require('colors');
const separationbar = colors.green('==================================================================================================')

//const yazl = require("yazl");

const BUILD_MODE_DBG = 'debug';
const BUILD_MODE_REL = 'release';

let stdout = null;
let projDir = process.cwd();
let installDir = "_Output/tweekit";

function executeCommand(cmd, isSilent = false){
    if (!isSilent) {
        console.log('\n')
        console.log('\n')
        console.log(colors.green(separationbar))
        console.log(colors.green('Performing :'))
        console.log(colors.yellow(cmd))
        console.log(colors.green(separationbar))
        console.log('\n')
    }

    const runCMd = execSync(cmd).toString()

    if (!isSilent) {
        console.log(runCMd)
    }

    if (!isSilent) {
        console.log(colors.green(separationbar))
        console.log('\n')
    }
}

function recurseForFileNames(dir, done) {
    let results = [];
    fs.readdir(dir, (err, list) => {
        if (err)
            return done(err);
        let pending = list.length;
        if (!pending)
            return done(null, results);
        list.forEach((file) => {
            file = path.resolve(dir, file);
            fs.stat(file, (err, stat) => {
                if (stat && stat.isDirectory()) {
                    recurseForFileNames(file, (err, res) => {
                        results = results.concat(res);
                        if (!--pending)
                            done(null, results);
                    });
                }
                else {
                    results.push(file);
                    if (!--pending)
                        done(null, results);
                }
            });
        });
    });
}

async function movePkgFile(pkgFilename, version) {
    let d = path.join(packageDir, version);
    let f = path.join(d, pkgFilename);
    const exists = fs.existsSync(f);
    if (!exists) {
        fs.mkdirSync(d);
        fs.copyFileSync(pkgFilename, f, fs.constants.COPYFILE_EXCL)
        execSync("rm " + pkgFilename);
    }
    else {
        console.log("Error:file already at dst");
    }
    console.log(`Build published to:${f}`);
    return 0;
}

async function publishPkgFile(files, appName, version) {
    let r = 0;
    var pkg = new yazl.ZipFile();
    for (let i = 0; i < files.length; i++) {
        pkg.addFile(files[i], path.basename(files[i]));
    }
    pkg.end();

    let f = `${appName}-${version}.zip`;
    let ws = fs.createWriteStream(f);
    await new Promise((resolve) => {
        pkg.outputStream.pipe(ws).on("close", resolve)
    });

    return movePkgFile(f, version);
}

function clean(buildMode) {
    let installPath = path.join(installDir, buildMode);

    console.log(`Cleaning install path:${installPath}...`);
    if(fs.existsSync(installPath))
        executeCommand("rm -rf " + installPath);
    console.log("done");
}

function checkIfFlagsAreValid(buildFlags) {
    const allowedBuildTypes = ['--npm', '--deploy-to-npm']
    let valid = true

    buildFlags.map(f => {
        valid = allowedBuildTypes.includes(f)

        // special conditions
        if (f === '--deploy-to-npm' && !buildFlags.includes('--npm')) {
            valid = false
            console.log(colors.red('\n\n\n'+separationbar))
            console.log(colors.red('ERROR: CANNOT USE DEPLOY TO NPM WITHOUT --npm FLAG'))
            console.log(colors.red(separationbar+'\n\n\n'))
        }
    })

    return valid
}

function build(buildMode, buildFlags) {
    // check if flags are valid
    const isValid = checkIfFlagsAreValid(buildFlags)
    if (!isValid) {
        usage();
        // if error do not proceed
        return false;
    }

    const makeNpmBuild = buildFlags.includes('--npm')
    const deployToNPM = buildFlags.includes('--deploy-to-npm')
    const isDeployableToNPM = buildMode === 'r' && makeNpmBuild && deployToNPM

    const suffixIfNpm = makeNpmBuild ? '-npm' : ''
    const webpackCmd = 'node_modules/webpack/bin/webpack.js'

    if (makeNpmBuild) {
        console.log(`Building the npm version of ${buildMode}...`);
    } else {
        console.log(`Building a standard version of ${buildMode}...`);
    }

    if(isDeployableToNPM) {
        //In release, before building bump the version
        executeCommand("npm version patch");
    }

    if(buildMode === 'r') {
        executeCommand(`node ${webpackCmd} --env NODE_ENV=production${suffixIfNpm}`);
    } else {
        executeCommand(`node ${webpackCmd} --env NODE_ENV=development${suffixIfNpm}`);
    }

    // after everything else is built and the
    // buildmode is release make sure
    // to publish it
    if(isDeployableToNPM) {
        executeCommand("npm publish");
    }

    console.log("done");
}

function usage() {
    executeCommand("clear", true)
    console.log('\n');
    console.log(separationbar);
    console.log('\n');
    console.log(`Usage:  build [${colors.green("cmds")}]`);
    console.log('\n');
    console.log("Commands:");
    console.log('\n');
    console.log(`\t ${colors.green("c")} -  Clean product of previous build`);
    console.log(`\t ${colors.green("b")}  - Build debug`);
    console.log(`\t ${colors.green("r")}  - Build release`);
    console.log('\n');
    console.log("Options:");
    console.log('\n');
    console.log(`\t ${colors.red("--npm")} - use this if you want the npm version of tweekit ( not applicable for local )`);
    console.log("Notes:");
    console.log('\n');
    console.log("\tMust be run from your projects main directory");
    console.log('\n');
    console.log(separationbar);
    console.log('\n');
}

function main() {
    const allowedBuildModes = ['b','r', 'c']

    const [
        ,,
        buildMode,
        ...buildFlags
    ] = process.argv

    console.log('buildType === ', buildFlags)

    if (buildMode && allowedBuildModes.includes(buildMode)) {
        if (buildMode === 'c') {
            clean(buildMode);
        } else {
            // either b or r
            build(buildMode, buildFlags);
        }
    } else {
        usage();
    }
}

main();
